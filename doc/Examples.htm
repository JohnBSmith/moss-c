<!doctype html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Examples</title>
  <link rel="stylesheet" href="css/main.css">
  <script src = "js/syntax.js">
  </script>
</head>
<body>

<h1>Examples</h1>

<div class="toc">
<h2 id="toc">Table of contents</h2>
<ol>
<li><a href="#fac">Factorial</a>
<li><a href="#fib">Fibonacci sequence</a>
<li><a href="#fc">Function composition</a>
<li><a href="#pa">Partial application</a>
<li><a href="#currying">Currying</a>
<li><a href="#rn">Random numbers</a>
<li><a href="#stat">Statistics</a>
<li><a href="#qsort">Quicksort</a>
<li><a href="#msort">Mergesort</a>
<li><a href="#cl">Combinatory logic</a>
<li><a href="#sets">Set theory</a>
<li><a href="#comb">Combinatorics</a>
<li><a href="#numerics">Numerics</a>
<li><a href="#Euler">Euler method</a>
<li><a href="#Lorenz">Lorenz attractor</a>
<li><a href="#la">Linear algebra</a>
<li><a href="#nt">Number theory</a>
<li><a href="#basic">Basic algorithms</a>
<li><a href="#ms">Mandelbrot set</a>
<li><a href="#rot13">ROT13</a>
<li><a href="#fft">FFT</a>
<li><a href="#lex">Lexical analysis</a>
<li><a href="#calc">Postfix calculator</a>
</ol>
</div>

<h2 id="fac">Factorial</h2>

<pre class="moss">
# Iterative
fac = sub|n|
  p=1
  for i in 1..n
    p=p*i
  end
  return p
end

# Recursive
fac = |n| if n==0 then 1 else n*fac(n-1) end

# Functional
fac = |n| (1..n).reduce(1,|x,y| x*y)

# Functional iteration
Fac = |x| [x[0]*x[1],x[1]+1]
fac = |n| (Fac^n)([1,1])[0]

# Semifunctional iteration
f = sub|n| i=0; (sub|x| i=i+1; x*i end^n)(1) end

# As a product
fac = |n| (1..n).prod()

# Recursive, with fixed-point combinator
fix = |F| sub g|n| F(g,n) end
fac = fix(|f,n| if n==0 then 1 else n*f(n-1) end)

# Tail-recursive
call = sub|f,m,n|
  x=f(m,n)
  while type(x) is function.type
    x=x()
  end
  return x
end

Fac = |m,n| n==0? m: || Fac(m*n,n-1)
fac = |n| call(Fac,1,n)

# Solve the functional equation
solve = sub|g,m,f0|
  a = list(0..m)
  a[0]=f0
  f = |x| a[x]
  for n in 1..m
    s=0
    while not g(f,n)
      s=s+1
      a[n]=s
      # print(a)
    end
  end
  return f
end

fac = sub|m|
  g = |f,n| f(n)==n*f(n-1)
  return solve(g,m,1)(m)
end

# Construct the list of permutations
fac = sub|n|
  size((list(1..n)^n).filter(sub|t|
    (1..n).all(|x| x in t)
  end))
end

# Recursive, Lisp style
eq = |a,b| a==b
mpy = |a,b| a*b
minus = |a,b| a-b
If = |c,f,g| if c then f() else g() end
define = sub|s,f|
  gtab()[s]=f
end

define("fac",|n|
  If(eq(n,0),
    || 1,
    || mpy(n,fac(minus(n,1)))))

# Tacit programming
compose = |f| |g| |x| f(g(x))
r = |a| |b| list(a..b)
mpy = |x,y| x*y
reduce = |f| |e| |a| a.reduce(e,f)

fac = compose(reduce(mpy)(1))(r(1))
</pre>

<h2 id="fib">Fibonacci sequence</h2>

<pre class="moss">
# Recursive
memo = sub|f|
  m={}
  return sub|n|
    if n not in m then m[n]=f(n) end
    return m[n]
  end
end

fib = |n| if n==1 or n==2 then 1 else fib(n-1)+fib(n-2) end
fib = memo(fib)

# Functional iteration
Fib = |x| [x[0]+x[1],x[0]]
fib = |n| (Fib^(n-1))([1,1])[1]

# By a general algorithm for
# a(n):=f(n,a(n-2),a(n-1))
rec = |a0,a1,f| sub|n|
  x,y=a0,a1
  for k in n
    x,y=y,f(k,x,y)
  end
  return x
end
fib = rec(0,1,|n,x,y| x+y)
</pre>


<h2 id="fc">Function composition</h2>
<pre class="moss">
compose = |f,g| |x| f(g(x))
f = |x| 2*x
print(compose(f,f)(10))

function.type.o = sub|g|
  f = self
  return |x| f(g(x))
end
print(f.o(f).o(f)(10))
</pre>


<h2 id="pa">Partial application</h2>
<pre class="moss">
first = |f,x| |y| f(x,y)
second = |f,y| |x| f(x,y)

# variadic, fix first arguments
first = |f,*a| |*b| f[a+b]

# variadic, fix last arguments
last = |f,*a| |*b| f[b+a]
</pre>


<h2 id="currying">Currying</h2>
<pre class="moss">
curry = sub|f|
  n=f.argc()
  a=list(0..n-1)
  g = sub|x| a[n-1]=x; f[a] end
  for i in 2..n
    g = sub|x| a[n-i]=x; g end
  end
  return g
end

curry = sub|f| n=f.argc(); a=list(0..n-1)
  return (2..n).reduce(sub|x| a[n-1]=x; f[a]
  end, |g,i| sub|x| a[n-i]=x; g end) end

uncurry = |f| |*a| a.reduce(f,|g,x| g(x))
</pre>


<h2 id="rn">Random numbers</h2>
<pre class="moss">
a = list(1..100).map(|x| rand(0,9))
print(a)

a = list(1..100).shuffle()
print(a)
</pre>


<h2 id="stat">Statistics</h2>
<pre class="moss">
use math: sqrt

# Mean value
mean = |a| a.sum()/size(a)
print(mean(1..4))
print(mean(rand(0,1).list(1000)))

# Estimated standard deviation
sigma = sub|a| m=mean(a)
  sqrt(a.sum(|x| (x-m)^2)/(size(a)-1))
end

# Variance
var = sub|a| m=mean(a)
  a.sum(|x| (x-m)^2)/size(a)
end

# Covariance
cov = sub|a,b| ma=mean(a); mb=mean(b)
  map(a,b,sub|x,y| (x-ma)*(y-mb) end).sum()/size(a)
end

# Covariance matrix
cov_matrix = |X| X.map(|a| X.map(|b| cov(a,b)))

# Pairwise summation
sub sum(a)
  while size(a)>3
    a = a.chunks(2).map(|t| t.sum())
  end
  return a.sum()
end

# Pairwise summation,
# traditional algorithm
sub sum(a)
  m=size(a)
  while m!=1
    i=0
    for k in 0..m-2: 2
      a[i] = a[k]+a[k+1]
      i++
    end
    if m%2!=0
      a[i]=a[m-1]
      i++
    end
    m=i
  end
  return a[0]
end
</pre>


<h2 id="qsort">Quicksort</h2>

<pre class="moss">
qsort = |a| if size(a)==0 then [] else
  qsort(a[1..].filter(|x| x&lt;a[0]))+[a[0]]+
  qsort(a[1..].filter(|x| x&gt;=a[0])) end

# Brevity for brevity's sake
q=|a|a==[]?[]:q(a[1..](|x|x&lt;a[0]))+[a[0]]+q(a[1..](|x|x&gt;=a[0]))

# Test function
issorted = |a| (0..size(a)-2).all(|i| a[i]&lt;=a[i+1])

# Alternative form
sub qsort(a)
  size(a)==0?[]:begin
    R,L=[],[]
    a[1..].each(|x|(x&lt;a[0]?R:L).push(x))
    return [R,L].map(qsort)
  end().reduce(|R,L| R+[a[0]]+L)
end
</pre>

<h2 id="msort">Mergesort</h2>

<pre class="moss">
msort = |a| if size(a)<=1 then copy(a) else
  merge(msort(a[1..:2]),msort(a[0..:2])) end

merge = sub|L,R| y=[]
  while size(L)!=0 and size(R)!=0
    y.push(if L[-1]>R[-1] then L else R end.pop())
  end
  return L+R+y.rev()
end
</pre>


<h2 id="cl">Combinatory logic</h2>

<pre class="moss">
I = |x| x
K = |x| |y| x
Y = |F| (|x| x(x))(|x| F(|n| x(x)(n)))
Y = |F| sub g|n| F(g)(n) end
S = |f| |x| |u| f(u)(x(u))
B = |f| |g| |x| f(g(x))
C = |f| |x| |u| f(u)(x)

# Y-Combinator without currying
Y = |F| sub g|n| F(g,n) end

# Y-Combinator with memoization
Y = sub|F|
  m={}
  return sub g|n|
    if n not in m then m[n]=F(g,n) end
    return m[n]
  end
end
</pre>

<h2 id="sets">Set theory</h2>

<pre class="moss">
# Powerset
P = |a| a.reduce({{}},|p,x| p|set(p.map(|s| s|{x})))

# Remove duplicates from a list
uniq = |a| list(set(a))

# Quotient set
partition = |a,R| set(list(a).chunks(R))

# Get equivalence relation
# from a quotient set Q
relation = |Q| |x,y| Q.any(|a| x in a and y in a)

# Get equivalence class
# from a quotient set Q
# and representative x
class = |Q,x| Q.find(|a| x in a)
</pre>

<h2 id="comb">Combinatorics</h2>

<pre class="moss">
# Permutations
perm = sub|a|
  if size(a)==0
    return [[]]
  end
  b=[]
  for i in 0..size(a)-1
    for x in perm(a[..i-1]+a[i+1..])
      b.push([a[i]]+x)
    end
  end
  return b
end

perm(list("abc")).map(|a| a.join()).each(print)
# abc
# acb
# bac
# bca
# cab
# cba

# Permutations with repetitions
(list("abc")^3).map(|a| a.join()).each(print)
# aaa
# aab
# ...
# ccc
</pre>


<h2 id="numerics">Numerics</h2>

<pre class="moss">
# Square root
sqrt = |a| (sub|x| 0.5*(x+a/x) end^10)(1)

# Differential operator
D = sub|f| h=0.001
  return |x| (f(x+h)-f(x-h))/(2*h)
end

f = |x| x^3+2*x
f1 = D(f)
f2 = D(D(f))
f2 = (D^2)(f)

# Simpson's rule
int = sub|f,a,b,n|
  h = (b-a)/n
  y=0
  for i in 0..n-1
    x = a+h*i
    y = y+f(x)+4*f(x+0.5*h)+f(x+h)
  end
  return y*h/6
end

int = sub|f,a,b,n| h=(b-a)/n
  list(n).map(|i| a+h*i).sum(|x| f(x)+4*f(x+0.5*h)+f(x+h))*h/6
end

# Newton's method
N = sub|f,x|
  f1 = D(f)
  for i in 1..20
    x=x-f(x)/f1(x)
  end
  return x
end

N = sub|f,x|
  f1 = D(f)
  phi = |t| t-f(t)/f1(t)
  return (phi^20)(x)
end
</pre>

<h2 id="Euler">Euler method</h2>

<pre class="moss">
use na: interpolate

# f'(x)=g(x,f(x))
# h: step size
# N: number of steps
sub euler(g,x0,y0,h,N)
  x=x0; y=y0
  a=[[x,y]]
  for k in 1..N
    y = y+h*g(x,y)
    x = x0+k*h
    a.push([x,y])
  end
  return interpolate(a)
end

# f^(m)(x) = g(x,y)
# y = [f(x),f'(x),...,f^(m-1)(x)]
sub euler_any_order(g,x0,y0,h,N)
  x=x0; y=copy(y0)
  m=size(y)
  a=[[x,y[0]]]
  for k in 1..N
    hg = h*g(x,y)
    for i in 0..m-2
      y[i] = y[i]+h*y[i+1]
    end
    y[m-1] = y[m-1]+hg
    x = x0+k*h
    a.push([x,y[0]])
  end
  return interpolate(a)
end

exp = euler(|x,y| y,
  0, 1, 0.01, 1000)
sin = euler_any_order(|x,y| -y[0],
  0, [0,1], 0.01, 1000)
</pre>

<h2 id="Lorenz">Lorenz attractor</h2>
<pre class="moss">
use ode
use plotlib: system

x,y,z = ode.runge_kutta_system({
  g = sub|t,v| x,y,z=v
    [10*(y-x),
     x*(28-z)-y,
     x*y-8/3*z]
  end,
  t0=0, y0=[1,1,1],
  w=40, unilateral
})

s = system({wx=50, wy=50, py=20})
s.vplot(|t| [x(t),z(t)],{
  t1=0, t2=40, n=80000
})
s.idle()
</pre>

<h2 id="la">Linear algebra</h2>

<pre class="moss">
# Jacobi method
use la: hv, hm, diag

sub Jacobi(A,b)
  d = A.diag()
  Dinv = diag(d.map(|x| 1/x))
  R = A-diag(d)
  x=b
  for k in 80
    x = Dinv*(b-R*x)
  end
  return x
end

A = hm(
  [4,1,2],
  [2,6,1],
  [1,3,9]
)
b = hv(1,2,3)
x = Jacobi(A,b)
print(x)
print(A*x-b)

# Determinant of a square matrix
use la: trace

sub det(A)
  a,b,c = [1,2,3].map(|k| trace(A^k))
  return a^3/6-a*b/2+c/3
end

# Matrix exponential
use math: fac
use la: hm

exp = |A| (0..20).sum(|k| A^k/fac(k))
A = hm([1,2],[3,4])
B = exp(A)
</pre>



<h2 id="nt">Number theory</h2>

<pre class="moss">
isprime = |n| n&gt;1 and (2..n-1).all(|k| n%k!=0)
print(list(1..100).filter(isprime))

# A prime is a number that has two divisors.
isprime = |n| (1..n).count(|k| n%k==0)==2

sieve = |a| if size(a)==0 then [] else
  [a[0]]+sieve(a[1..].filter(|x| x%a[0]!=0)) end

print(sieve(list(2..100)))

gcd = |a,b| if b==0 then a else gcd(b,a%b) end

gcd = sub|a,b|
  while b!=0 do a,b=b,a%b end
  return a
end

lcm = |a| a.reduce(|x,y| x*y//gcd(x,y))

# (a^n)%m (built-in as pow(a,n,m))
powmod = sub|a,n,m|
  y=1; a=a%m
  while n&gt;0
    if n%2==0
      n=n//2; a=(a*a)%m
    else
      n=n-1; y=(y*a)%m
    end
  end
  return y
end

# List of divisors
divisors = |n| list(1..n).filter(|k| n%k==0)

# Divisor function
sigma = |x,n| (1..n).filter(|k| n%k==0).sum(|k| k^x)

sigma0 = |n| (1..n).count(|k| n%k==0)

# Prime factorization
factor = |n| (list(2..n).filter(|k| n%k==0 and isprime(k))
  .map(|p| [p,(1..).until(|k| n%(p^k)!=0).count()]))
</pre>


<h2 id="basic">Basic algorithms</h2>

<pre class="moss">
# Any base
integer = |s,b| s.reduce(0,|x,c| b*x+ord(c)-ord('0'))
base = |n,b| x==0? "0": base(n//b,b)+chr(n%b+ord('0'))

base = sub|n,b|
  s = n==0? "0": ""
  while n!=0
    s=chr(n%b+ord('0'))+s
    n=n//b
  end
  return s
end

# Abstract version (mathematically pure)
base = |n,b| n==0? []: base(n//b,b)+[n%b]

# Custom digits
base = sub|n,s| b=size(s)
  n&lt;b? s[n]: base(n//b,s)+s[n%b]
end

# Reverse
rev = sub|a|
  n=size(a)-1
  for i in 0..size(a)//2-1
    a.swap(i,n-i)
    # a[i],a[n-i] = a[n-i],a[i]
  end
end
</pre>


<h2 id="ms">Mandelbrot set</h2>

<pre class="moss">
(0..25).map(|x|
  (0..39).map(sub|y| c = (x/10-2)+(y/10-2)*1i
    abs((sub|z| z^2+c end^10)(0))&lt;2? "*": "\s"
  end).join()).each(print)
</pre>


<h2 id="rot13">ROT13</h2>

<pre class="moss">
rot13 = |s| s.map(|c|
  c in 'a'..'z'? chr((ord(c)-97+13)%26+97):
  c in 'A'..'Z'? chr((ord(c)-65+13)%26+65): c).join()
</pre>

<h2 id="fft">FFT</h2>

<pre class="moss">
use math: pi
use cmath: exp

# size(a) is a power of two
fft = sub|a| if size(a)<=1 then return a end
  even = fft(a[0..:2]); odd = fft(a[1..:2])
  N = size(a); L = list(0..N//2-1)
  T = L.map(|k| exp(-2i*pi*k/N)*odd[k])
  return (L.map(|k| even[k]+T[k])+
          L.map(|k| even[k]-T[k])) end
</pre>


<h2 id="lex">Lexical analysis</h2>
<pre class="moss">
# Simple tokenizer

syntax_error = object()

sub scan(s)
  a=[]
  i=0; n=size(s)
  while i&lt;n
    if s[i] in "+-*/^(){}[];,"
      a.push(s[i])
      i++
    elif s[i].isalpha()
      j=i
      while i&lt;n and s[i].isalnum()
        i++
      end
      a.push(s[j..i-1])
    elif s[i].isdigit()
      j=i
      while i&lt;n and s[i].isdigit()
        i++
      end
      a.push(s[j..i-1])
    elif s[i].isspace()
      i++
    else
      raise table[syntax_error]
        value="unexpected character: '"+s[i]+"'"
      end
    end
  end
  return a
end

while true
  s = input("&gt; ")
  try
    print(scan(s))
  catch e: syntax_error
    print("Syntax error: ", e.value, ".")
  end
end

# Without syntax errors
use re
regex = re.compile("{d}+ | {a}({a}|{d})* | [+-*/^(){}[];,]")
scan = |s| regex.list(s)
</pre>


<h2 id="calc">Postfix calculator</h2>
<pre class="moss">
use re
unary={"~": |x| -x}; binary={"+": |x,y| x+y, "-": |x,y| x-y,
  "*": |x,y| x*y, "/": |x,y| x/y, "^": |x,y| x^y}
regex = re.compile("{d}+({.}{d}*)?|[+-*/^~]")
calc = |s| regex.list(s).reduce([],|a,x| x[0].isdigit()?
  a+[float(x)]: x in unary? a[..-2]+[unary[x](a[-1])]:
  a[..-3]+[binary[x](a[-2],a[-1])])[-1]
(|| calc(input("&gt;\s"))).each(print)
</pre>

</body>
</html>

