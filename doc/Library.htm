<!doctype html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Libray</title>
  <link rel="stylesheet" href="css/main.css">
  <script src = "js/syntax.js">
  </script>
</head>
<body>

<h1>Library reference</h1>

<h2 id="toc">Table of contents</h2>

<ol>
<li><a href="#global">Global functions</a>
<li><a href="#list">Type list</a>
<li><a href="#string">Type string</a>
<li><a href="#dict">Type dictionary</a>
<li><a href="#function">Type function</a>
<li><a href="#iterable">Type iterable</a>
<li><a href="#sys">Module sys</a> &mdash; runtime system interface
<li><a href="#time">Module time</a> &mdash; time measurement
<li><a href="#os">Module os</a> &mdash; operating system interface
<li><a href="#math">Module math</a> &mdash; mathematical functions
<li><a href="#cmath">Module cmath</a> &mdash; complex functions
<li><a href="#sf">Module sf</a> &mdash; special mathematical functions
<li><a href="#na">Module na</a> &mdash; numerical analysis
<li><a href="#nt">Module nt</a> &mdash; number theory
<li><a href="#cf">Module cf</a> &mdash; combinatorical functions
<li><a href="#gx">Module gx</a> &mdash; graphics
</ol>

<h2 id="global">Global functions</h2>

<dl class="code">
<dt>print(x1,...,xn)</dt>
<dd>Prints its arguments to the command-line interface.
The output representations of
the arguments are joined together without any separating character
or spacing. Does print a line break thereafter. If the function is
called with no argument, it only prints a line break.</dd>

<dt>put(x1,...,xn)</dt>
<dd>Does the same as print, but does not print a line break.
</dd>

<dt>input(), input(prompt)</dt>
<dd>Read a line of input from the command-line interface and return
the input as a string. The line break at the end of the input line is
not contained in the string.
</dd>

<dt>str(x)</dt>
<dd>Convert <code>x</code> into a string.
</dd>

<dt>str(x,format,precision)</dt>
<dd>Convert the floating point number <code>x</code> into
a string.
<pre class="moss">
# format = "[+|-](f|e|E|g|G)"
s = str(math.pi,"f",4)
</pre>
</dd>

<dt>int(x)</dt>
<dd>Convert <code>x</code> into an integer if possible.
</dd>

<dt>float(x)</dt>
<dd>Convert <code>x</code> into a floating point number
  if possible.
</dd>

<dt>ord(s)</dt>
<dd>Take a string of length one and return the code point of the
  Unicode character.
</dd>

<dt>chr(x)</dt>
<dd>Take an integer value <code>x</code> and return the Unicode
  character at code point&nbsp;<code>x</code>.
</dd>

<dt>list(x)</dt>
<dd>Convert the iterable object <code>x</code> into a list.
<pre class="moss">
&gt; list(1..4)
[1, 2, 3, 4]
</pre>
</dd>

<dt>dict(x)</dt>
<dd>Convert the iterable object <code>x</code> of
<code>[key,value]</code> pairs into a dictionary.
<pre class="moss">
&gt; {"a": 1, "b": 2} == dict([["a",1],["b",2]])
true
</pre>
</dd>


<dt>iter(x)</dt>
<dd>Take an iterable object and return an iterator.
<pre class="moss">
&gt; i = iter(1..)
&gt; [i(),i(),i(),i()]
[1, 2, 3, 4]
</pre>
</dd>

<dt>size(a)</dt>
<dd>Number of elements of <code>a</code>. The object <code>a</code>
should be a data structure that has this property.
</dd>

<dt>rand(a..b), rand(a..b,seed)</dt>
<dd>Return a random number generator that returns random integers
from <code>a</code> inclusive to <code>b</code> inclusive.
<pre class="moss">
&gt; r = rand(1..4)
&gt; [r(),r(),r(),r()]
[2, 1, 3, 3]
&gt; r.list(10)
[1, 1, 4, 2, 3, 4, 1, 2, 1, 1]
</pre>
</dd>

<dt>rand(a), rand(a,seed)</dt>
<dd>Return a random number generator that chooses an element of
the list <code>a</code> randomly.
</dd>

<dt>rand(), rand(seed)</dt>
<dd>Return a random number generator that returns floats
between zero and one.
</dd>

<dt>read(id), read(id,mode)</dt>
<dd>Read the text file with filename <code>id</code> and encoding
<code>UTF-8</code>. Return the contents as an
<code>UTF32</code>-string. If <code>mode=='b'</code>,
the file is read as a binary file.
</dd>

<dt>load(id)</dt>
<dd>Load the module with filename <code>id</code> and
  return the module object. The function <code>load</code>
  can be used in a more general way than the import statement.
<pre class="moss">
&gt; math = load("math")
&gt; math.floor(2.4)
2.0
</pre>
</dd>

<dt>abs(x)</dt>
<dd>Absolute value of <code>x</code>. Returns an integer if
<code>x</code> is an integer. Takes also complex numbers.</dd>

<dt>sgn(x)</dt>
<dd>Sign of <code>x</code>. Returns an integer if
<code>x</code> is an integer. Takes also complex numbers.</dd>

<dt>max(a,b)</dt>
<dd>Return the maximum of <code>a</code> and <code>b</code>.
</dd>

<dt>min(a,b)</dt>
<dd>Return the minimum of <code>a</code> and <code>b</code>.
</dd>

<dt>pow(a,n,m)</dt>
<dd>Modular exponentiation: calculate <code>(a^n)%m</code> fast.
</dd>

<dt>const(x), const(n,x)</dt>
<dd>Shallow freeze a mutable object <code>x</code> and return it.
If <code>n</code> is given, deep freeze <code>x</code> by
depth <code>n</code>.
If <code>n</code> is <code>null</code>, freeze the complete
tree. Note that <code>const(x)</code> is equivalent to
<code>const(1,x)</code>.
</dd>

<dt>copy(x)</dt>
<dd>Construct a shallow copy of the object <code>x</code>.
</dd>

<dt>object(), object(p), object(p,d)</dt>
<dd>Construct a new object with <code>p</code> as its
prototype and dictionary <code>d</code> as its slot table.
</dd>

<dt>type(x)</dt>
<dd>Prototype of <code>x</code>.
</dd>

<dt>record(x)</dt>
<dd>Slot table of <code>x</code>.
</dd>

<dt>extend(a,b)</dt>
<dd>Insert all slots of <code>b</code> into the slot
table of <code>a</code>. Already existent slots
of <code>a</code> will not be overwritten.
</dd>

<dt>assert(e,s)</dt>
<dd>If <code>e</code> is false, raise an assertion failed exception
with informational text <code>s</code>.
</dd>

<dt>map(a1,...,an,f)</dt>
<dd>Take the lists <code>a1,...,an</code> and return
a list with the elements <code>f(a1[i],...,an[i])</code>.
</dd>

<dt>zip(a1,...,an)</dt>
<dd>Take the lists <code>a1,...,an</code> and return the list of
lists <code>[a1[i],...,an[i]]</code>.

<dt>unzip(a)</dt>
<dd>See what it does.
<pre class="moss">
&gt; unzip([["x1", "y1"], ["x2", "y2"], ["x3", "y3"]])
[["x1", "x2", "x3"], ["y1", "y2", "y3"]]
</pre>
</dd>

<dt>eval(s)</dt>
<dd>Execute a string as a program.
<pre class="moss">
&gt; x=12
&gt; eval("2*x")
24
&gt; eval("a=[1,2]")
&gt; a
[1, 2]
</pre>
</dd>
</dl>


<h2 id="list">Type list (<a href="#iterable">iterable</a>)</h2>

<dl class="code">
<dt>a.push(x)</dt>
<dd>Append <code>x</code> to <code>a</code>.
</dd>

<dt>a.pop()</dt>
<dd>Remove the last element of <code>a</code> and
return it.
</dd>

<dt>a.pop(i)</dt>
<dd>Remove the element at index <code>i</code> from <code>a</code>
and return it. Thus, <code>a.pop(0)</code> removes the first element.
</dd>

<dt>a.insert(i,x)</dt>
<dd>Insert the object <code>x</code> at index <code>i</code>.
Beforehand all elements from index <code>i</code> inclusive onwards
are shiftet one position to the right.
</dd>

<dt>a.extend(b)</dt>
<dd>Append all elements from <code>b</code> to <code>a</code>.
</dd>

<dt>a.map(f)</dt>
<dd>Create a shallow copy of <code>a</code>, apply the
function <code>f</code> to every element of this copy and return
the result.
<pre class="moss">
&gt; [1,2,3,4].map(|x| 2*x)
[2, 4, 6, 8]
</pre>
</dd>

<dt>a.filter(p)</dt>
<dd>Filter all elements from <code>a</code> for which the
predicate <code>p</code> is true.
<pre class="moss">
&gt; [1,2,3,4].filter(|x| x%2==0)
[2, 4]
</pre>
</dd>

<dt>a.rev()</dt>
<dd>Reverse <code>a</code> and return it.
Does not construct a shallow copy, <code>a</code> itself will be
modified.
<pre class="moss">
&gt; list(1..4).rev()
[4, 3, 2, 1]
</pre>
</dd>

<dt>a.shuffle()</dt>
<dd>Shuffle <code>a</code> randomly and return it.
Does not construct a shallow copy, <code>a</code> itself will be
modified.
<pre class="moss">
&gt; list(1..10).shuffle()
[10, 9, 5, 3, 1, 7, 6, 2, 8, 4]
</pre>
</dd>

<dt>a.chain()</dt>
<dd>Construct a new list with the same elements, but if elements
of <code>a</code> are lists or ranges, these will be unpacked.
<pre class="moss">
&gt; [[1,2],[3,4]].chain()
[1, 2, 3, 4]
&gt; [[1,2],11..14,3,4].chain()
[1, 2, 11, 12, 13, 14, 3, 4]
</pre>
</dd>

<dt>a.chunks(n)</dt>
<dd>Construct a new list with the same elements, but the elements
are grouped to chunks of size <code>n</code>.
<pre class="moss">
&gt; [1,2,3,4,5,6].chunks(2)
[[1, 2], [3, 4], [5, 6]]
</pre>
</dd>

<dt>a.chunks(R)</dt>
<dd>Construct a new list with the same elements, but the elements
are grouped by equivalence relation <code>R</code> to equivalence
classes.
<pre class="moss">
&gt; [1,2,3,4,5,6].chunks(|x,y| x%3==y%3)
[[1, 4], [2, 5], [3, 6]]
</pre>
</dd>

<dt>a.dict(f)</dt>
<dd>Construct a dictionary with <code>f(x)[0]</code> as key and
<code>f(x)[1]</code> as value for each <code>x</code> in <code>a</code>.
<pre class="moss">
&gt; [1,2,3,4].dict(|x| [x,x^2])
{1: 1, 2: 4, 3: 9, 4: 16}
</pre>

<dt>a.sort(), a.sort(p), a.sort(p,cmp)</dt>
<dd>Sort the list and return it. Does not construct a shallow
copy, <code>a</code> itself will be modified. The function
<code>p</code> is a projection on which the sorting is based.
The function <code>cmp</code> is an alternative binary comparison
function. The sorting algorithm is not required to be stable.
<pre class="moss">
&gt; a = ["oak", "Elm", "willow", "birch"]
&gt; a.sort()
["Elm", "birch", "oak", "willow"]
&gt; a.sort(|x| x.lower())
["birch", "Elm", "oak", "willow"]
&gt; a.sort(size)
["oak", "Elm", "birch", "willow"]
&gt; a.sort(null,|x,y| x&gt;y)
["willow", "oak", "birch", "Elm"]
</pre>
</dd>
</dl>

<h2 id="string">Type string (<a href="#iterable">iterable</a>)</h2>

<dl class="code">
<dt>s.lower()</dt>
<dd>Return the string <code>s</code> projected to lower case.
<pre class="moss">
&gt; "Bee".lower()
"bee"
</pre>
</dd>

<dt>s.upper()</dt>
<dd>Return the string <code>s</code> projected to upper case.
<pre class="moss">
&gt; "Bee".upper()
"BEE"
</pre>
</dd>

<dt>s.islower()</dt>
<dd>Return only true if the string <code>s</code> is empty or all
letters are in lower case.</dd>

<dt>s.isupper()</dt>
<dd>Return only true if the string <code>s</code> is empty or all
letters are in upper case.</dd>

<dt>s.isalpha()</dt>
<dd>Return only true if the string <code>s</code> is empty or consists only
of letters.</dd>

<dt>s.isdigit()</dt>
<dd>Return only true if the string <code>s</code> is empty or consists only
of digits.</dd>

<dt>s.isalnum()</dt>
<dd>Return only true if the string <code>s</code> is empty or each character
is a letter or a digit.</dd>

<dt>s.isrange(a,b)</dt>
<dd>Return only true if the string <code>s</code> is empty or consists only
of characters from Unicode code point <code>a</code> inclusive
to <code>b</code> inclusive. You may also write
<code>s.isrange(c,d)</code> instead of
<code>s.isrange(ord(c),ord(d))</code>.
</dd>

<dt>s.ltrim(), s.ltrim(chars)</dt>
<dd>Remove withespace from the left side. If a string
<code>chars</code> is given, remove characters
until a character is found, that is not contained in
<code>chars</code>.
</dd>

<dt>s.rtrim(), s.rtrim(chars)</dt>
<dd>Remove withespace from the right side.
</dd>

<dt>s.trim(), s.trim(chars)</dt>
<dd>Remove withespace from the left and right side.
</dd>
</dl>

<h2 id="dict">Type dictionary  (<a href="#iterable">iterable</a>)</h2>

<dl class="code">
<dt>d.list()</dt>
<dd>Return the list of keys.</dd>

<dt>d.values()</dt>
<dd>Return an iterator of the values.</dd>

<dt>d.items()</dt>
<dd>Return an iterator of the key-value pairs.</dd>

<dt>d.update(d2)</dt>
<dd>Insert all items of <code>d2</code> into
<code>d</code>. Already in <code>d</code> contained items
are overwritten.</dd>

<dt>d.extend(d2)</dt>
<dd>Insert all items of <code>d2</code> into
<code>d</code>, but do not overwrite already in <code>d</code>
contained items.</dd>

<dt>d.add(key)</dt>
<dd>Add a key to the dictionary.</dd>

<dt>d.remove(key)</dt>
<dd>Remove an item from the dictionary. Raise an exception
if the key is not found.</dd>

<dt>d.clear()</dt>
<dd>Remove all items of <code>d</code>.
</dd>
</dl>

<h2 id="function">Type function (<a href="#iterable">iterable</a>)</h2>

<dl class="code">
<dt>f.call(self,x1,...,xn)</dt>
<dd>Apply the function <code>f</code> to the
arguments <code>x1,...,xn</code> and self argument
<code>self</code>.
</dd>

<dt>f.apply(self,a)</dt>
<dd>Apply the function <code>f</code> to the arguments
<code>a[0],...,a[-1]</code>. If there is no self-argument,
the application shall be written <code>f.apply(null,a)</code>.
</dd>

<dt>f.orbit(x)</dt>
<dd>Return an iterator that produces
<code>[x,f(x),f(f(x)),...]</code>.
<pre class="moss">
&gt; (|x|2*x).orbit(2).list(10)
[2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]
</pre>
</dd>

<dt>i.list(), i.list(n)</dt>
<dd>Take the iterator <code>i</code> and return its elements
as a list. If <code>n</code> is given, a maximum number of
<code>n</code> elements will be taken.
<pre class="moss">
&gt; iter(1..).list(4)
[1, 2, 3, 4]
</pre>
</dd>

<dt>i.until(p)</dt>
<dd>Take elements from the iterator&nbsp;<code>i</code>
as long as the predicate&nbsp;<code>p</code> is false and return
a new iterator.
</dd>
</dl>

<h2 id="iterable">Type iterable</h2>
<dl class="code">
<dt>a.all(p), a.all()</dt>
<dd>Universal quantifier: Return only true if the
predicate <code>p</code> is true for all elements of <code>a</code>.
<pre class="moss">
&gt; [1,2,3,4].all(|x| x%2==0)
false
</pre>
</dd>

<dt>a.any(p), a.any()</dt>
<dd>Existential quantifier: Return true if the
predicate <code>p</code> is true for at least one element
of <code>a</code>.
<pre class="moss">
&gt; [1,2,3,4].any(|x| x%2==0)
true
</pre>
</dd>

<dt>a.count(p), a.count()</dt>
<dd>Apply predicate <code>p</code>
to every element of <code>a</code> and
count how often it is true. If no predicate is given, the
total number of elements will be returned.
<pre class="moss">
&gt; [1,2,3,4].count(|x| x%2==0)
2
</pre>
</dd>

<dt>a.sum(f), a.sum()</dt>
<dd>Calculate the sum of all <code>f(x)</code> for <code>x</code>
in <code>a</code>.
</dd>

<dt>a.prod(f), a.prod()</dt>
<dd>Calculate the product of all <code>f(x)</code> for <code>x</code>
in <code>a</code>.
</dd>

<dt>a.reduce(f), a.reduce(e,f)</dt>
<dd>Reduce the iterable <code>a</code> from left to right by the
binary function <code>f</code>. That means, if <code>f</code> is
regarded as a left associative binary operator, this operator is
inserted between all elements of <code>a</code>.
If <code>e</code> is given, it is used as initial element.
<pre class="moss">
# 1+2+3+...+99+100
&gt; (1..100).reduce(|x,y| x+y)
5050

&gt; (1..4).reduce("#",|x,y| x+"/"+str(y))
"#/1/2/3/4"

&gt; fac = |n| (1..n).reduce(1,|x,y| x*y)
&gt; fac(6)
720
</pre>
</dd>

<dt>a.map(f)</dt>
<dd>Apply the function <code>f</code> to every element of
<code>a</code> and return a new iterator.
<pre class="moss">
&gt; (1..).map(|x| x^2).list(10)
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
</pre>
</dd>

<dt>a.filter(p)</dt>
<dd>Filter all elements from <code>a</code>
for which the predicate&nbsp;<code>p</code> is true and
return a new iterator.
<pre class="moss">
&gt; isprime = |n| (1..n).count(|k| n%k==0)==2
&gt; (1..).filter(isprime).list(10)
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
</pre>
</dd>

<dt>a.max(), a.max(p)</dt>
<dd>Return the maximum of a. Return the maximum based on a
projection <code>p</code>.
</dd>

<dt>a.min(), a.min(p)</dt>
<dd>Return the minimum of a. Return the minimum based on a
projection <code>p</code>.
<pre class="moss">
&gt; a = [[1,"dca"],[2,"b"],[3,"ab"]]
&gt; a.min(|t| t[0])
[1, "dca"]
&gt; a.min(|t| t[1])
[3, "ab"]
&gt; a.min(|t| size(t[1]))
[2, "b"]
</pre>
</dd>

<dt>a.join()</dt>
<dd>Apply <code>str</code> to each element and join the strings
together.
<pre class="moss">
&gt; ["a","b","c"].join()
"abc"
</pre>
</dd>

<dt>a.join(sep)</dt>
<dd>Apply <code>str</code> to each element and join the strings
together with <code>sep</code> inserted between.
<pre class="moss">
&gt; ["a","b","c"].join("#*")
"a#*b#*c"
</pre>
</dd>

<dt>a.dict(f)</dt>
<dd>Equivalent to <code>dict(a.map(f))</code>.
</dd>

</dl>


<h2 id="sys">Module sys</h2>

<p>Interface to the runtime system.
</p>

<dl class="code">
<dt>argv</dt>
<dd>List of command-line arguments.</dd>

<dt>path</dt>
<dd>List of search paths for module loading, analogous to
the environment variable <code>PATH</code>.
This list can be changed freely and can contain relative paths.
But note, that relative paths are problematic, if the current
working directory changes. That <code>path[0]</code> should be the
absolute path of the directory where <code>argv[0]</code>
is found.</dd>

<dt>exit(n)</dt>
<dd>Exit the program with integer return value <code>n</code>.
Zero means success, other values indicate an error.
</dl>

<h2 id="time">Module time</h2>

<dl class="code">
<dt>sleep(x)</dt>
<dd>Halt execution and continue after <code>x</code> seconds.
The number <code>x</code> can be a float and thus fractional parts of
a second are possible.
</dd>

<dt>clock()</dt>
<dd>Start a new stop watch that returns time in seconds.
<pre class="moss">
c = time.clock()
time.sleep(0.1)
print(c())
</pre>
</dd>

<dt>time()</dt>
<dd>Obtain Gregorian calendar date and UTC time.
<pre class="moss">
# Format (each of type integer):
  [year, month, day, hour, minute, second]
# Example:
template = "{4(0)}-{2(0)}-{2(0)}T{2(0)}:{2(0)}:{2(0)}"
print(template % time.time())
</pre>
</dd>
</dl>


<h2 id="os">Module os</h2>
<p>Interface to the operating system.
</p>

<dl class="code">
<dt>wd()</dt>
<dd>Working directory.</dd>

<dt>cd(id)</dt>
<dd>Change directory.</dd>

<dt>ls(), ls(id)</dt>
<dd>List all nodes in directory <code>id</code>. Does not list the
nodes <code>"."</code> and <code>".."</code>. If there is no
argument, the nodes in the working directory are listed.
</dd>

<dt>isdir(id)</dt>
<dd>Return true if the node <code>id</code> is a directory.
</dd>

<dt>isfile(id)</dt>
<dd>Return true if the node <code>id</code> is a file.
</dd>

<dt>not_found</dt>
<dd>Type object of the exception that is raised if a file or
directory was not found.
<pre class="moss">
try
  a = os.ls("documents/computer/network")
catch e: os.not_found
  print("oops: ",e.value)
end
</pre>
</dd>
</dl>


<h2 id="math">Module math</h2>
<p>Basic mathematical functions.
</p>

<dl class="code">
<dt>e</dt>
<dd>Euler's number <code>2.71828...</code></dd>

<dt>pi</dt>
<dd><code>3.14159...</code></dd>

<dt>nan</dt>
<dd>Not a number.</dd>

<dt>inf</dt>
<dd>Infinity.</dd>

<dt>floor(x)</dt>
<dd>Round down. Returns floating point numbers.</dd>

<dt>ceil(x)</dt>
<dd>Round up. Returns floating point numbers.</dd>

<dt>sqrt(x)</dt>
<dd>Square root of <code>x</code>.</dd>

<dt>exp(x)</dt>
<dd>Exponential function.</dd>

<dt>log2(x)</dt>
<dd>Logarithm to base 2.</dd>

<dt>ln(x)</dt>
<dd>Logarithm to base e.</dd>

<dt>lg(x)</dt>
<dd>Logarithm to base 10.</dd>

<dt>lg(x,b)</dt>
<dd>Logarithm to base <code>b</code>.</dd>

<dt>sin(x), cos(x), tan(x)</dt>
<dd>Sine, cosine and tangent.</dd>

<dt>asin(x), acos(x), atan(x)</dt>
<dd>Arc sine, arc cosine and arc tangent.</dd>

<dt>sinh(x), cosh(x), tanh(x)</dt>
<dd>Hyperbolic sine, hyperbolic cosine and hyperbolic tangent.
</dd>

<dt>asinh(x), acosh(x), atanh(x)</dt>
<dd>Inverse functions of the hyperbolic functions.
</dd>

<dt>fac(x)</dt>
<dd>Factorial function. Returns floating point numbers.</dd>

<dt>gamma(x)</dt>
<dd>Gamma function.</dd>

<dt>lgamma(x)</dt>
<dd>Return <code>ln(abs(gamma(x)))</code>.</dt>

<dt>sgngamma(x)</dt>
<dd>Return <code>sgn(gamma(x))</code>.</dt>

<dt>hypot(x1,...,xn)</dt>
<dd>Return <code>sqrt(x1^2+...+xn^2)</code>.</dd>

<dt>atan2(y,x)</dt>
<dd>Return the phase angle of the coordinate vector
<code>[x,y]</code>.
</dd>

<dt>expm1(x)</dt>
<dd>Return <code>exp(x)-1</code>.</dd>

<dt>ln1p(x)</dt>
<dd>Return <code>ln(1+x)</code>.</dd>

<dt>isfinite(x)</dt>
<dd>Return true if <code>x</code> is not infinite and not a NaN.
</dd>

<dt>isnan(x)</dt>
<dd>Return true if <code>x</code> is a NaN.
</dd>

<dt>isinf(x)</dt>
<dd>Return true if <code>x</code> is infinite.
</dd>

<dt>frexp(x)</dt>
<dd>Take <code>x==m*2^n</code> and return <code>[m,n]</code>.
The type of <code>m</code> is float, the type of <code>n</code> is int.
</dd>

<dt>ldexp(m,n)</dt>
<dd>Return <code>m*2^n</code>.</dd>
</dl>


<h2 id="cmath">Module cmath</h2>
<p>Mathematical functions that can take or return complex numbers.
</p>

<dl class="code">
<dt>re(z)</dt>
<dd>Real part of <code>z</code>.
</dd>

<dt>im(z)</dt>
<dd>Imaginary part of <code>z</code>.
</dd>

<dt>conj(z)</dt>
<dd>Complex conjugate.</dd>

<dt>sqrt(z)</dt>
<dd>Square root.</dd>

<dt>exp(z)</dt>
<dd>Exponential function.</dd>

<dt>ln(z)</dt>
<dd>Natural logarithm.</dd>

<dt>sin(z), cos(z), tan(z)</dt>
<dd>Sine, cosine and tangent.</dt>

<dt>sinh(z), cosh(z), tanh(z)</dt>
<dd>Hyperbolic sine, hyperbolic cosine and hyperbolic tangent.
</dd>

<dt>asinh(z), acosh(z), atanh(z)</dt>
<dd>Inverse functions of the hyperbolic functions.
</dd>

<dt>gamma(z)</dt>
<dd>Gamma function.</dd>
</dl>

<h2 id="sf">Module sf</h2>

<p>Special mathematical functions.
</p>

<h3>Basic functions</h3>
<p>The combinatorical functions stated here are implemented
for numercial purposes. For that reason, approximated floats are
returned instead of exact long integers.
</p>

<dl class="code">
<dt>bc(n,k)</dt>
<dd>Binomial coefficient.</dd>

<dt>B(n)</dt>
<dd>Bernoulli number, <code>B(1)=+1/2</code>.
</dd>
</dl>

<h3>Gamma and related functions</h3>
<dl class="code">
<dt>Beta(x,y)</dt>
<dd>Beta function.</dd>

<dt>Gamma(s,z)</dt>
<dd>Upper incomplete gamma function.</dd>

<dt>gamma(s,z)</dt>
<dd>Lower incomplete gamma function.</dd>

<dt>digamma(z)</dt>
<dd>Digamma function.</dd>

<dt>polygamma(n,z)</dt>
<dd>Polygamma function.</dd>
</dl>

<h3>Antiderivatives</h3>
<dl class="code">
<dt>erf(z)</dt>
<dd>Error function.</dd>
</dl>

<h3>Zeta and related functions</h3>
<dl class="code">
<dt>zeta(s)</dt>
<dd>Zeta function.</dd>

<dt>zeta(s,q)</dt>
<dd>Hurwitz zeta function.</dd>
</dl>

<h3>Polynomial functions</h3>
<dl class="code">
<dt>PP(n,x), P(n,m,x)</dt>
<dd>Legendre polynomial.</dd>

<dt>PH(n,x), PH(n,m,x)</dt>
<dd>Hermite polynomial and derivative of order <code>m</code>.</dd>

<dt>PT(n,x), PU(n,x)</dt>
<dd>Chebyshev polynomial of the first and second kind.
</dd>

<dt>PL(n,x), P(n,m,x)</dt>
<dd>Laguerre Polynomial and generalized Laguerre polynomial.
</dd>
</dl>

<h3>Elliptic integrals and related functions</h3>
<dl class="code">
<dt>eiK(m), m=k^2</dt>
<dd>Complete elliptic integral of the first kind.
</dd>

<dt>eiE(m), m=k^2</dt>
<dd>Complete elliptic integral of the second kind.
</dd>

<dt>agm(x,y)</dt>
<dd>Arithmetic geometric mean of <code>x</code> and <code>y</code>.
</dd>
</dl>


<h2 id="na">Module na</h2>
<p>Numerical analysis.
</p>

<dl class="code">
<dt>diff(f,x), diff(f,x,n)</dt>
<dd>Derivative of <code>f</code> at <code>x</code>.
The <code>n</code>-th derivative of <code>f</code> at <code>x</code>.
</dd>

<dt>integral(a,b,f), integral(a,b,f,N)</dt>
<dd>Definite integral.
<pre class="moss">
ln = |x| integral(1,x,|t| 1/t)
</pre>
</dd>

<dt>vint(c,f), vint(c,f,N)</dt>
<dd>Contour integral of a complex function <code>f</code>
by vertex path <code>c</code>. Integral of a complex valued
function <code>f</code> by <code>c=[a,b]</code>.
<pre class="moss">
ln = |z| vint([1,im(z)&lt;0?-1i:1i,z],|s| 1/s)

cint = |gamma,f| vint([0,1],|t| f(gamma(t))*diff(gamma,t))
</pre>
</dd>

<dt>inv(f,x,a,b)</dt>
<dd>Value of the inverse function of <code>f</code> at <code>x</code> for
<code>f</code> strictly monotonic on the interval <code>[a,b]</code>.
The bisection method is used.
</dd>

<dt>interpolate(a)</dt>
<dd>Linear piecewise interpolation: Take an ordered (by <code>x</code>)
list of pairs <code>[x,y]</code> and return a function.
</dd>
</dl>

<h2 id="nt">Module nt</h2>

<p>Number theory.
</p>

<dl class="code">
<dt>base(n,b)</dt>
<dd>Transform the number <code>n</code> into positional notation
with base <code>b</code>. The result is in little endian
(least significant digit first).
</dd>

<dt>base(n,b).rev()</dt>
<dd>Big endian (least significant digit last) of the
positional notation above.
</dd>

<dt>isprime(n)</dt>
<dd>Deterministic primality test.</dd>

<dt>isprime(n,e)</dt>
<dd>Probalistic primality test with false positive probability of less than
<code>1/(2^e)</code></dt>.
</dd>

<dt>gcd(x,y), gcd(a)</dt>
<dd>Greatest common divisor of <code>x,y</code> (of the numbers
in the list <code>a</code>).</dd>

<dt>lcm(x,y), lcm(a)</dt>
<dd>Least common multiple of <code>x,y</code>
(of the numbers in the list <code>a</code>).

<dt>factor(n)</dt>
<dd>Prime factorization of <code>n</code>.
</dd>

<dt>divisors(n)</dt>
<dd>List of divisors of <code>n</code>.
</dd>

<dt>phi(n)</dt>
<dd>Euler's totient function.
</dd>

<dt>lambda(n)</dt>
<dd>Carmichael function.
</dd>
</dl>


<h2 id="cf">Module cf</h2>

<p>Combinatorical functions.</p>
<dl class="code">
<dt>fac(n)</dt>
<dd>Factorial.</dd>

<dt>rf(n,k)</dt>
<dd>Rising factorial.</dd>

<dt>ff(n,k)</dt>
<dd>Falling factorial.</dd>

<dt>bc(n,k)</dt>
<dd>Binomial coefficient.
</dd>

<dt>mc([k1,...,kn])</dt>
<dd>Multinomial coefficient.
</dd>

<dt>Stirling1(n,k)</dt>
<dd>Stirling numbers of the first kind.
</dd>

<dt>Stirling2(n,k)</dt>
<dd>Stirling numbers of the second kind.
</dd>

<dt>Delta(n,f,x,h)</dt>
<dd>Finite difference, iterated <code>n</code> times.
<pre class="moss">
Delta = |n,f,x,h| ((|x| f(x+h)-f(x))^n)(x)
</pre>
</dd>

</dl>


<h2 id="gx">Module gx</h2>

<p>Computer graphics.
</p>

<dl class="code">
<dt>gx.new(w,h,size)</dt>
<dd>Return a new canvas that has a width of <code>w</code> pixels and
a height of <code>h</code> pixels. The edge length of a pixel
is <code>size</code> screen pixels.</dd>

<dt>gx.HSL(h,s,l)</dt>
<dd>Take a HSL color and return the corresponding RGB color.
</dd>

<dt>canvas.flush()</dt>
<dd>Flush the canvas buffer to the screen.</dd>

<dt>canvas.pset(x,y)</dt>
<dd>Draw a pixel at position <code>[x,y]</code>.</dd>

<dt>canvas.fill(x,y,w,h)</dt>
<dd>Fill a rectangle of pixels.</dd>

<dt>canvas.cset(r,g,b,a=1), canvas.cset([r,g,b],a=1)</dt>
<dd>Set the color state by using the RGB color space. The values
<code>r,g,b</code> are floating point numbers from the interval
<code>[0,1]</code>. If a number is out of bounds, the
extremal value is used. That <code>a</code> is the alpha value
for alpha compositing.</dd>

<dt>canvas.HSL(h,s,l)</dt>
<dd>Set the color state by using the HSL color space. The value
<code>h</code> is from the interval <code>[0,2pi]</code>, the values
<code>s,l</code> are from the interval <code>[0,1]</code>.
If <code>h</code> is out of bounds, <code>h</code> modulo 2pi is
used. If <code>s,l</code> are out of bounds, the extremal value
is used.
<pre>
red......h=000*pi/180
green....h=120*pi/180
blue.....h=240*pi/180

cyan.....h=180*pi/180
magenta..h=300*pi/180
yellow...h=060*pi/180
</pre>
</dd>

<dt>canvas.key()</dt>
<dd>Return the next key from the queue of pressed
keys. Returns <code>null</code> if the queue is empty.</dd>

<dt>canvas.point(x,y)</dt>
<dd>Draw a point at position <code>[x,y]</code>. The position
<code>[0,0]</code> is in the middle of the canvas, the coordinate
system is orthonormal. The value <code>x</code> is a float from
the interval <code>[-1,1]</code>, otherwise the point won't be drawn.
Anti-aliasing will be used.</dd>

<dt>canvas.point()</dt>
<dd>Draw a point at position state. The rules are as above.</dd>
</dl>


</body>
</html>

