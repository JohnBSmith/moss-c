<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Blog</title>
  <link rel="stylesheet" href="css/main.css">
  <script src="js/blog.js">
  </script>
</head>
<body>

<h1>Development blog</h1>
<h2>Table of contents</h2>
<div id="toc" class="toc"></div>

<h3 data-date="20160808" id="new-formatted-printing-policy"
>New formatted printing policy</h3>
<p>Separation between formatted printing to <code>stdout</code> and string
buffers shall be resolved. Formatted printing to <code>stdout</code>
shall be removed in favor of string buffers.
</p>

<h3 data-date="20160808" id="new-formatted-printing-function"
>New formatted printing function</h3>
<p>Moss gets a function and syntax for formatted printing.
I&nbsp;will compare it with equivalents from&nbsp;C.
</p>
<pre>
   C: printf("(%li,%li)",x,y)
Moss: print("({},{})"%[x,y])

   C: snprintf(s,N,"(%li,%li)",x,y)
Moss: s = "({},{})" % [x,y]
</pre>
<p>The template syntax will be similar to <code>format</code>
from Python but may differ more or less.
</p>
<pre>
# Here is an example of proper usage:
a = list(0..10).map(|x| [x,x^2])
buffer=[]
for t in a
  buffer.push("({},{})"%t)
end
s = buffer.join("\n")
print(s)

# More briefly:
/*1*/ a = list(0..10).map(|x| [x,x^2])
/*2*/ s = a.map(|t| "({},{})"%t).join("\n")
/*3*/ print(s)
</pre>
<p>We see a practical pattern: a strict separation between actual
information structure (1), formatting (2) and stdout (3).
</p>
<p>Note: to have advanced output, libraries should be provided
that return tables as HTML5, LATEX2E and plots as PNG, SVG
as automatically as possible. Whole documents or books (libraries?)
could be generated automatically from data. But one must say
to this, that HTML5 is more easy to use than LATEX2E.
</p>

<h3 data-date="20160920" id="set-dict-joined"
>Joined datatypes dictionary and set</h3>
<p>As sets are a special case of dictionaries and set operations
do not interfere with dictionary operations, them can be joined.
Dictionaries with values absent can be considered as sets:
</p>
<pre class="moss">
  {1, 2} == {1: null, 2: null}
</pre>
<p>Multisets cannot be included as well, because
they introduce problems. For example, '<code>==</code>' behaves
differently if there are keys with <code>d[key]==0</code>.
But it is clear that dictionaries will be used as internal data
structures of multisets.
</p>

<h3 data-date="20160930" id="assignment-to-application"
>Assignments to function applications</h3>
<p>A syntactical sugar for assignments to function
applications is added to the language.
</p>
<pre>
1. a.m()=y is equivalent to a.set_m(y)
2. a.m(x1,...,xn)=y is equivalent to a.set_m(x1,...,xn,y)
3. a.m(x) = y1,y2 the same as a.m(x)=[y1,y2]
     and therefore equivalent to a.set_m(x,[y1,y2])
4. a.m1(),a.m2() = t is not possilbe (t=[y1,y2])
5. a[i]()=y is not possible
</pre>
<p>The point in (4) is that the language should be minimalistic
and (4) would blow it up. It is definitely much harder to
implement than (1,2,3) which required less than 40 lines of code.
</p>

<h3 data-date="20161006" id="print-float">
Printing floating point numbers</h3>

<pre>
There is a problem with standard printing of floating point
numbers. For example, one can get
&gt; list(0..1:0.2)
[0.0, 0.2, 0.4, 0.6000000000000001, 0.8, 1.0]

So we can have output of the form 000000000...some digit
and (under other circuumstances)  999999999...some digit.
This is because of printf("%.16g\n",x)
In most cases one has engineering tasks and does not suffer
from slightly lower precision. So I think I will change that
to %.14g to make output more stable. One can always get full
precision by "{g16}"%[x] or even "{g17}"%[x].
(#include &lt;float.h&gt;: DBL_DECIMAL_DIG==17)
</pre>

<h3 data-date="20161107" id="Rust">
Reimplementation in Rust</h3>

<p>It is clear for me now, that the Moss interpreter must be
rewritten in Rust. I&nbsp;have to struggle with segmentation faults
too often. Rust is one of the strictest languages I know.
It is very well thought.
</p>

<h3 data-date="20161107" id="self"
>New syntax for a formal self-argument</h3>

<p>The standard syntax for formal self-arguments
has a problem. The following is not possible,
bacause the inner self-argument shadows the outer one:
<pre class="moss">
  function.type.o = |g| |x| self(g(x))
</pre>
<p>One is forced to write instead:
<pre class="moss">
function.type.o = sub|g|
  f=self
  return |x| f(g(x))
end
</pre>
<p>This problem occurs often if one uses methods, because
closures and higher order functions are frequently used.
Now the idea is, to separate the self-argument via an semicolon
from the other arguments. For actual arguments this syntax is
already possible, but I will provide it also for formal
arguments. Then we have:
<pre class="moss">
  function.type.o = |f;g| |x| f(g(x))
</pre>

<h3 data-date="20170509" id="about-modules"
>About modules</h3>

<p>What is the difference between what follows? Firstly:
<pre class="moss">
  m = load("m")
</pre>
<p>And secondly:
<pre class="moss">
  m = eval(read("m.moss"))
</pre>
<p>Behavior is different, because <code>eval</code>
returns a value rather than a module object. But the question that
comes into mind is: should they be equivalent? In order to achieve
that, in a module a module object should be returned explicitely rather
than implicitely. This would also solve another problem: How to
state a module that consists only of a single class or a single
function (to achieve advanced lazy loading and lazy evaluation)?
The problem here is an oddly looking import statement:
<pre class="moss">
  use class_name: class_name
  # vs.
  use class_name
</pre>
<p>Note that <code>eval</code> can be made quite powerful. It can
take an additional argument that specifies information about
the environment. For example, global variable of the environment
are used by default by <code>eval</code>. If a module would be loaded,
<code>eval</code> had to take an empty environment.

<h3 data-date="20170509" id="default-arguments"
>Default arguments</h3>

<p>The interpreter already supports default arguments for
build in functions. Now a function's argument count can simply be
a range. Not given arguments will be filled out with
<code>null</code>. Now
<pre class="moss">
  sub f(x,y=expression)
</pre>
<p>is simply syntatic sugar for
<pre class="moss">
  sub f(x,y=null)
    if y is null then y=expression end
</pre>
<p>An implementation is straightforward:
<ol>
<li>Let argument count be a range.
<li>Take the assignment AST and obtain that desired if-AST from it.
<li>Insert this if-AST before function body. To be more precise:
At first, the function body is parsed, and then we have both:
if-AST and body-AST.
</ol>
<p>Now construct:
<pre>
  * block-node
    * if-node-1
    * if-node-2
      ...
    * if-node-n
    * body-node
</pre>
<p>Easy going. At next, default named arguments are stated as follows:
<pre class="moss">
  sub f(x,d={})
    a = d["a"] if "a" in d else a0
    b = d["b"] if "b" in d else b0
    # ...
  end
</pre>
<p>That's clumsy. I believe, default named arguments are very important
for usability and thus should be supported by the language. Now let
<pre class="moss">
  {a=a0, b=b0} = d
</pre>
<p>be syntactic shugar for
<pre class="moss">
  a = d["a"] if "a" in d else a0
  b = d["b"] if "b" in d else b0
</pre>
<p>Without default arguments it should be more strict: Let
<pre class="moss">
  {a,b} = d
</pre>
<p>be syntactic shugar for
<pre class="moss">
  a = d["a"]; b = d["b"]
</pre>
<p>I call this the <em>dictionary unpacking statement</em>.

<p>It took me 100 lines of C&nbsp;code to implement dictionary
unpacking, including construction of a temporary variable if the right
hand side is an expression. I think it was a worthwhile effort.

<p>Finally it could be moved into the arguments list:
<pre class="moss">
  sub f(x,{a=a0,b=b0})
    # ...
  end
</pre>
<p>Furthermore,
<pre class="moss">
  sub f([x,y])
    # ...
  end
</pre>
<p>could be
<pre class="moss">
  sub f(_t0_)
    x,y = _t0_
    # ...
  end
</pre>

</body>
</html>

